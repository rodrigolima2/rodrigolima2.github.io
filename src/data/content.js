import reactContextImg1 from "../assets/images/react-context-img1.png";
import reactContextImg2 from "../assets/images/react-context-img2.png";
import reactContextImg3 from "../assets/images/react-context-img3.png";
import reactContextImg4 from "../assets/images/react-context-img4.png";
import reactContextImg5 from "../assets/images/react-context-img5.png";
import reactContextImg6 from "../assets/images/react-context-img6.png";
import reactContextImg7 from "../assets/images/react-context-img7.png";
import reactContextImg8 from "../assets/images/react-context-img8.png";
import reactContextImg9 from "../assets/images/react-context-img9.png";
import reactContextImg10 from "../assets/images/react-context-img10.png";
import reactContextImg11 from "../assets/images/react-context-img11.png";
import reactContextImg12 from "../assets/images/react-context-img12.png";
import reactContextImg13 from "../assets/images/react-context-img13.png";
import reactContextImg14 from "../assets/images/react-context-img14.png";
import reactContextImg15 from "../assets/images/react-context-img15.png";
import reactContextImg16 from "../assets/images/react-context-img16.png";
import reactContextImg17 from "../assets/images/react-context-img17.png";
import reactContextImg18 from "../assets/images/react-context-img18.png";

import reactHooksImg1 from "../assets/images/react-hooks-img1.png";
import reactHooksImg2 from "../assets/images/react-hooks-img2.png";
import reactHooksImg3 from "../assets/images/react-hooks-img3.png";
import reactHooksImg4 from "../assets/images/react-hooks-img4.png";
import reactHooksImg5 from "../assets/images/react-hooks-img5.png";

import reactRouterDomImg1 from "../assets/images/react-router-dom-img1.png";
import reactRouterDomImg2 from "../assets/images/react-router-dom-img2.png";
import reactRouterDomImg3 from "../assets/images/react-router-dom-img3.png";
import reactRouterDomImg4 from "../assets/images/react-router-dom-img4.png";
import reactRouterDomImg5 from "../assets/images/react-router-dom-img5.png";

import javascriptImg1 from "../assets/images/javascript-img1.png";
import javascriptImg2 from "../assets/images/javascript-img2.png";
import javascriptImg3 from "../assets/images/javascript-img3.png";
import javascriptImg4 from "../assets/images/javascript-img4.png";
import javascriptImg5 from "../assets/images/javascript-img5.png";

import arrayIncludesImg1 from "../assets/images/array-includes-img1.png";

import stringIncludesImg1 from "../assets/images/string-includes-img1.png";


const content = [
    {
        title: "React",
        content: [
            {
                subtitle: "O que é React?",
                text: `React JS é uma biblioteca JavaScript para a criação de interfaces de usuário — ou UI (user interface).
                Criado em 2011 pelo time do Facebook, o React surgiu com o objetivo de otimizar a atualização e a sincronização de atividades simultâneas no feed de notícias da rede social, entre eles chat, status, listagem de contatos e outros.
                A princípio, todas essas atividades, chamadas de estados, tinham uma descrição muito complexa. Com o React, esta descrição torna-se mais simples, bem como também é simplificada a conexão entre HTML, CSS e JavaScript e todos os componentes de uma página.
                Por ter demonstrado grande eficiência, nos anos que se seguiram o React foi incorporado à interface de outras redes sociais do grupo, como o Instagram e, em 2013, seu código foi aberto à comunidade, dando início a sua popularização.
                Hoje, o React é uma das mais prestigiadas bibliotecas de JavaScript do mercado.`
            },
            {
                subtitle: "Como funciona o React?",
                text: `O React é uma biblioteca front-end e tem como um de seus objetivos facilitar a conexão entre diferentes partes de uma página, portanto seu funcionamento acontece através do que chamamos de componentes.
                Em outras palavras, podemos imaginar que o React divide uma tela em diversos componentes para, então, trabalhar sobre eles de maneira individual.
                Os componentes são utilizados para reaproveitamento de código e padronização de interface.
                Isso torna o React uma tecnologia muito flexível para a solução de problemas e para a construção de interfaces reutilizáveis, uma vez que cada um destes componentes pode ser manipulado de maneira distinta.`
            },
            {
                subtitle: "Como o React usa JavaScript?",
                text: `O React é uma biblioteca que utiliza a linguagem de programação JavaScript.
                O JS é uma das mais versáteis e populares linguagens de programação do mundo e conta com um grande número de bibliotecas e outras tecnologias que a utilizam. Entre elas, Node.js, Angular, VueJS, jQuery, Ember.js e, é claro, o React.
                Por essa razão, se você quer aprender a manipular esta biblioteca e extrair dela todo o seu potencial, é preciso antes ter uma sólida base de conhecimento em JavaScript, bem como em suas outras duas linguagens de marcação: HTML e CSS.
                Isso porque o React utiliza uma extensão alternativa ao JavaScript para descrever seus componentes. Esta sintaxe é chamada de JSX.
                O JSX, a grosso modo, é uma linguagem desenvolvida como uma mistura de HTML e JS. Seu objetivo é ser transposta para JS da maneira mais simplificada possível.`
            },
            {
                subtitle: "Qual a diferença entre React e React Native?",
                text: `Esta é uma dúvida muito comum para quem ainda é novato no universo de front-end, JavaScript e seus recursos.
                O React é uma biblioteca criada para construir telas de forma declarativa. Ou seja: o React cria aplicações web para serem executadas em navegadores, sejam eles para desktop, mobile ou qualquer outro dispositivo.
                Para que essas aplicações possam ser transpostas para diferentes dispositivos, algumas bibliotecas são utilizadas — e o React Native é uma delas.
                O React Native é a biblioteca voltada para a criação de aplicativos mobile em Android e iOS.
                Em suma, a diferença entre React e React Native é que o primeiro diz respeito à maneira geral com que a biblioteca trabalha, enquanto o segundo traduz o JavaScript para a linguagem nativa do dispositivo, tanto para iOS quanto para Android.`
            },
            {
                subtitle: "Componentes",
                text: `O uso de componentes é um dos pilares de sustentação do React.
                Para compreender e agir sobre uma determinada página, o React a quebra em pequenos pedaços, chamados de componentes, e os isola, sendo cada um deles independentes entre si perante a tecnologia.
                Estes componentes são reutilizáveis e, uma vez categorizados, podem ser reaproveitados em quaisquer páginas de um site ou aplicativo.
                Os componentes de uma página podem ser organizados, por exemplo, em BarraLateral, MenuSuperior, BotaoChamada, ou da maneira que o programador preferir.
                Os componentes podem ser comparados às funções em JavaScript.`
            },
            {
                subtitle: "Props (properties)",
                text: `Dentro dos componentes estão as propriedades, ou props. Estas props são objetos com várias informações que podem ser de variados tipos, como função, número ou string.`
            },
            {
                subtitle: "State (estado)",
                text: `Assim como as propriedades, os estados, ou states, também são objetos ou informações, mas ao invés de serem passadas para o componente, eles são criados dentro do componente.
                Diferentemente das propriedades, os states são mutáveis, como por exemplo variáveis declaradas dentro de uma função.`
            },
            {
                subtitle: "Virtual DOM",
                text: `O Virtual DOM, ou VDOM, é uma representação em memória de um DOM (Document Object Model) real de uma interface.
                Na prática, DOM real é a estrutura que representa a camada visual de uma página.
                Para que fique mais claro, imagine o seguinte processo:
                Para atualizar uma página, o React primeiro salva suas alterações em memória, ou seja, em um ambiente chamado de Virtual DOM. Isso acontece porque manipular um DOM virtual é muito mais rápido do que manipular um DOM real — ou seja, a página que está sendo atualizada.
                Em front-end, a atualização de DOMs é extremamente corriqueira, uma vez que é através deles que as páginas de um site ou aplicativo são efetivamente atualizadas.
                Após criada esta estrutura virtual, o React a traduz para a tela real com o mínimo de processos possível, trazendo mais agilidade para a atualização. Este processo é chamado de reconciliação.`
            },
            {
                subtitle: "JSX",
                text: `Como citado acima, o JSX é uma sintaxe muito parecida com HTML, mas com elementos de JS. 
                Todos os componentes do React são descritos com o JSX, então se você pretende trabalhar com o React e todo o seu universo de possibilidades, é necessário aprender antes a compreender o JSX.
                A boa notícia é que esta sintaxe é muito simples de ser assimilada!`
            }
        ]
    },
    {
        title: "React Context",
        content: [
            {
                text: `Contexto (context) disponibiliza uma forma de passar dados entre a árvore de componentes sem precisar passar props manualmente em cada nível.
                Em uma aplicação típica do React, os dados são passados de cima para baixo (de pai para filho) via props, mas esse uso pode ser complicado para certos tipos de props (como preferências locais ou tema de UI), que são utilizadas por muitos componentes dentro da aplicação. Contexto (context) fornece a forma de compartilhar dados como esses, entre todos componentes da mesma árvore de componentes, sem precisar passar explicitamente props entre cada nível.`
            },
            {
                subtitle: "Quando Usar Contexto",
                text: `Contexto (context) é indicado para compartilhar dados que podem ser considerados “globais” para a árvore de componentes do React. Usuário autenticado ou o idioma preferido, são alguns casos comuns. No exemplo do código a seguir, nós passamos um tema a fim de estilizar o componente Button.`,
                img: reactContextImg1
            },
            {
                text: `Usando contexto, nós podemos evitar passar prop através de elementos intermediários.`,
                img: reactContextImg2
            },
            {
                subtitle: "Antes de você usar Contexto",
                text: `Contexto (context) é usado principalmente quando algum dado precisa ser acessado por muitos componentes em diferentes níveis. Use contexto moderadamente uma vez que isto pode dificultar a reutilização de componentes.
                Se você apenas quer evitar passar algumas props por muitos níveis, composição de componente geralmente é uma solução mais simples que Contexto (context).
                Considere por exemplo o componente Page que passa as props user e avatarSize por vários níveis abaixo de modo que os componentes Link e Avatar profundamente aninhados, podem ler essas props.`,
                img: reactContextImg3
            },
            {
                text: `Pode parecer redundante passar para baixo as props user e avatarSize através de vários níveis se no final apenas o componente Avatar realmente precisa usa-las. Além disso, é incômodo sempre que o componente Avatar precisar de mais props do topo, você também precisar adicionar todas elas por todos os níveis intermediários.
                Uma forma de resolver este problema sem contexto é atribuir o próprio componente Avatar a uma prop do componente Page, assim os componentes intermediários não precisam saber sobre a prop user ou o avatarSize:`,
                img: reactContextImg4
            },
            {
                text: `Com esta mudança, apenas o componente Page do topo precisa saber sobre os componentes Link e Avatar e das props user e avatarSize.
                Esta inversão de controle pode fazer seu código mais limpo em vários casos, reduzindo a quantidade de props que você precisa passar através da sua aplicação e dando mais controle para os componentes raíz. Essa inversão, entretanto, não é a escolha certa em todos os casos; mover mais complexibilidade para o topo da árvore, faz com que estes componentes fiquem mais complicados e forçando os componentes dos níveis mais abaixo ficarem mais flexíveis do que você gostaria.
                Você não está limitado a um único filho por componente, Você pode passar vários componentes filhos ou até mesmo ter vários slots de componentes filhos como documentado aqui:`,
                img: reactContextImg5
            },
            {
                text: `Este padrão é suficiente para vários casos onde você precisa separar um componente filho de seu pai imediato. Você pode ainda ir mais longe com render props se o filho precisa se comunicar com o pai antes de ser renderizado.
                Contudo, às vezes o mesmo dado precisa ser acessado por vários componentes na árvore e em diferentes níveis de aninhamento. Contexto (context) deixa você “transmitir” este dado e mudanças do mesmo para todos componentes abaixo. Exemplos comuns onde usar contexto pode ser mais simples que as alternativas incluem o gerenciamento de localização atual, tema, ou um dado em cache.`
            },
            {
                subtitle: "API"
            },
            {
                subtitle2: "React.createContext",
                example: `const MyContext = React.createContext(defaultValue);`
            },
            {
                text: `Cria um objeto Contexto (context). Quando o React renderiza um componente que assina este objeto Contexto (context), este vai ler o valor atual do Provider superior na árvore que estiver mais próximo.
                O argumento defaultValue (valor padrão) é usado apenas quando o componente não corresponder com um Provider acima dele na árvore. Este valor padrão pode ser útil para testar componentes isoladamente, sem envolvê-los. Observação: passando undefined como um valor de Provider não faz com que os componentes consumidores do Provider usem defaultValue.`
            },
            {
                subtitle2: "Context.Provider",
                example: `<MyContext.Provider value={/* some value */}>`
            },
            {
                text: `Cada objeto Contexto (context) vem com um componente Provider que permite componentes consumidores a assinarem mudanças no contexto.
                O componente Provider aceita uma prop value que pode ser passada para ser consumida por componentes que são descendentes deste Provider. Um Provider pode ser conectado a vários consumidores. Providers podem ser aninhados para substituir valores mais ao fundo da árvore.
                Todos consumidores que são descendentes de um Provider serão renderizados novamente sempre que a prop value do Provider for alterada. A propagação do Provider aos seus descendentes (incluido .contextType e useContext), não está condicionada ao método shouldComponenteUpdate, logo, o consumidor é atualizado mesmo quando um componente antepassado ignora uma atualização.
                Mudanças são determinadas comparando os valores novos com os anteriores usando o mesmo algoritimo de Object.is.
                Nota:
                A forma como as mudanças são determinadas, podem causar alguns problemas quando se atribui objetos como value: veja Ressalvas`
            },
            {
                subtitle2: "Class.contextType",
                img: reactContextImg6
            },
            {
                text: `A propriedade contextType pode ser atribuída a um objeto Contexto (Context) criado por React.createContext(). Usar esta propriedade permite que você consuma o valor atual mais próximo deste tipo de contexto usando this.context. Você pode referencia-lo em qualquer momento nos métodos de ciclo-de-vida, incluindo a função render.
                Nota:
                Você pode assinar apenas um contexto usando esta API. Se você precisa ler mais de um contexto, veja Consumindo vários Contextos.
                Se você está usando o recurso experimental public class fields syntax, você pode usar um campo estático da classe para inicializar o seu contextType.`,
                img: reactContextImg7
            },
            {
                subtitle2: "Context.Consumer",
                img: reactContextImg8
            },
            {
                text: `Um componente React que assina mudanças de contexto. Usar este componente permite você assinar a um contexto por um function component.
                Requer uma function as a child. A função recebe o valor atual do contexto e retorna um nó React. O argumento value passado para a função será igual ao value da prop do Provider do contexto mais próximo acíma na árvore. Se não houver um Provider para este contexto acima, o argumento value será igual a defaultValue que foi passado ao criar o contexto com createContext().
                Nota:
                Para mais informações sobre o padrão “function as a child” veja, render props.`
            },
            {
                subtitle2: "Context.displayName",
                text: `O objeto Context aceita uma propriedade string displayName. React DevTools usa essa string para determinar o que exibir para o contexto.
                Por exemplo, o seguinte componente aparecerá como MyDisplayName no DevTools:`,
                img: reactContextImg9
            },
            {
                subtitle: "Exemplos"
            },
            {
                subtitle2: "Contexto Dinâmico",
                text: `Um exemplo mais complexo com valores dinâmicos para o tema:`
            },
            {
                subtitle2: "theme-context.js",
                img: reactContextImg10
            },
            {
                subtitle2: "themed-button.js",
                img: reactContextImg11
            },
            {
                subtitle2: "app.js",
                img: reactContextImg12
            },
            {
                subtitle: "Atualizando o Contexto de um componente aninhado",
                text: `Geralmente é necessário atualizar o contexto de um componente que está aninhado em algum lugar da árvore de componentes. Neste caso, você pode passar uma função para o contexto, permitindo assim que consumidores possam atualizar o contexto.`
            },
            {
                subtitle2: "theme-context.js",
                img: reactContextImg13
            },
            {
                subtitle2: "theme-toggler-button.js",
                img: reactContextImg14
            },
            {
                subtitle2: "app.js",
                img: reactContextImg15
            },
            {
                subtitle: "Consumindo vários Contextos",
                text: `Para que o contexto possa continuar renderizando rapidamente, o React precisa manter cada consumidor de contexto separado em um nó da árvore.`,
                img: reactContextImg16
            },
            {
                text: `Se dois ou mais valores de contexto são utilizados juntos com frequência, você pode considerar criar o seu próprio render prop.
                Nota:
                Para mais informações sobre render prop, veja render props.`
            },
            {
                subtitle: "Ressalvas",
                text: `Contexto (context) usa referência de identidade para determinar quando renderizar novamente, por este motivo, existem alguns casos que podem desencadear renderizações não intencionais em consumidores quando algum componente que antecede um Provider é renderizados. Por exemplo, o código abaixo vai re-renderizar todos consumidores toda vez que o Provider re-renderizar porque um novo objeto é sempre criado para value:`,
                img: reactContextImg17
            },
            {
                text: `Para contornar isso, mova a prop value para o state do nível antecessor.`,
                img: reactContextImg18
            },
            {
                subtitle: "API Legada",
                text: `Nota:
                Versões anteriores do React foram disponibilizadas com uma versão experimental do context API. Esta versão antiga da API será suportada em todas versões 16.x lançadas mas, aplicações utilizando esta API, devem migrar para a nova versão. Leia aqui em API Legada.`
            }
        ]
    },
    {
        title: "React Hooks",
        content: [
            {
                text: `Até a versão 16.7 do React algumas funcionalidades só eram possíveis de ser acessadas através de classes (como, por exemplo, o lifecycle). Apesar da possibilidade de criar componentes a partir de função, até essa versão, eles só recebiam propriedades, não podendo acessar todas as funcionalidades do React, como as classes. Na versão 16.8 do React, foram lançado os hooks, que permitem o uso de vários recursos de forma simples através de funções. Eles também ajudam a organizar a lógica utilizada dentro dos componentes.
                Dentro da nossa rotina de desenvolvimento, uma tarefa comum é a criação de um portfólio para mostrarmos as nossas habilidades para possíveis recrutamentos, um amigo ou até mesmo para que a gente possa ter um histórico da nossa evolução enquanto devs. Normalmente, colocamos os nossos projetos dentro do Github, porém, se a gente quiser criar o nosso site para mostrar estes projetos, como faríamos?
                Em nosso projeto com React, teremos um componente que será responsável por listar os nossos repositórios do GitHub. Gostaríamos de ter uma estrutura como esta abaixo:`,
                img: reactHooksImg1
            },
            {
                text: `Já temos a nossa lista de repositórios, correto? Porém, se a gente quiser adicionar mais repositórios, teríamos que criar mais <li> para isso, pois o nosso código ainda está estático. Como faremos para gerar essa lista de maneira dinâmica?`
            },
            {
                subtitle: "Hook useEffect",
                text: `Com o nosso componente criado, podemos começar a adicionar as funcionalidades. Iremos construir uma aplicação que lista os repositórios da nossa conta do GitHub, então precisarei acessar a API deles. Faremos uma requisição HTTP utilizando o fetch do JavaScript para buscar a lista de repositórios desta API. Vale ressaltar que o fetch gera efeitos colaterais (desejados ou não) em nosso código, pois ele é uma operação de I/O (input/output).
                A documentação oficial do React nos orienta como lidar com efeitos colaterais em nossos componentes, então vamos utilizar o hook useEffect para lidar com estes efeitos gerados pelo fetch() com o código abaixo:`,
                img: reactHooksImg2
            },
            {
                text: `O hook useEffect nos auxilia a lidar com os side-effects (efeitos colaterais) e podemos usá-los também como ciclo de vida do componente.
                No exemplo acima, o side-effect é a chamada API. Este hook recebe dois parâmetros: o primeiro é uma função que será executada quando o componente for inicializado e atualizado (pode ser assíncrona ou não). Em nosso exemplo, este primeiro parâmetro é uma arrow function assíncrona, que faz uma requisição à API e guarda na const resposta, em formato de json, e, depois, na const repositorios. Já o segundo parâmetro indica em qual situação o side-effect irá modificar. No nosso caso, como queremos carregar a lista somente uma vez, passamos um array vazio [], pois ele garante a execução única (parecido com o funcionamento do componentDidMount()).
                Agora que já estamos trazendo os dados da API, como fazemos para gerar uma lista dinâmica a partir desses dados?`
            },
            {
                subtitle: "Hook useState",
                text: `Com os dados da API em mãos, precisamos conseguir armazená-los em uma lista e depois exibi-los em tela, mas como podemos fazer isto?
                Vamos pensar…
                Usamos o hook useEffect para controlar os side-effects da requisição HTTP fetch() que fizemos, após a chamada, há uma mudança de estado dentro da nossa aplicação, pois ela passa a ter os dados vindos da API que antes não tinha. Para que possamos lidar com as mudanças de estado da nossa aplicação, iremos usar o hook useState. Para isso, usamos o hook desta forma:`,
                img: reactHooksImg3
            },
            {
                text: `O useState, que permite a criação de estado no componente através de função e faz o gerenciamento do estado local do componente retorna um array como resultado. Por isso, é possível fazermos uma desestruturação para receber partes desse retorno. O array de retorno possui dois índices. O primeiro valor deste array é uma variável que guarda o estado em si, que chamamos de repositorio. Já o segundo valor é uma variável que é uma função, e é através dela que faremos as atualizações do valor do nosso estado, usamos setRepositorio para nomear a nossa função, o set vem antes do nome por ser uma convenção da comunidade.
                Como a nossa função setRepositorio é a responsável por alterar o estado de repositorio, precisamos colocá-la dentro do escopo da função useEffect, porque ela é a responsável por pegar os dados que vão modificar o estado da nossa aplicação. Desta forma, nossa função useEffect fica assim:`,
                img: reactHooksImg4
            },
            {
                text: `A diferença dentro dessa função é que retiramos o return repositorios e adicionamos a função setRepositorios(), passando como parâmetro a constante repositorios, pois, como foi explicado, é essa função responsável por atualizar os estado da nossa aplicação.
                Agora que já temos os dados dos repositórios vindo da API do GitHub e estamos atualizando o estado da nossa aplicação com eles, o último passo é exibir ele de forma dinâmica dentro da tag ul desta forma:`,
                img: reactHooksImg5
            },
            {
                text: `Para que fosse possível gerar dinamicamente, utilizamos o método map() para poder percorrer o nosso array repositorio, que possui a lista de repositórios, e imprimir um a um na tela.`
            },
            {
                subtitle: "React Hooks",
                text: `Os hooks permitem o uso de state e outros recursos que antes só eram possíveis dentro do React através de classes. Apesar disso, os hooks são opcionais, ficando a seu critério se vai usá-los ou continuar usando as classes. Clicando aqui você pode ver dentro da documentação oficial do React as principais motivações que levaram à criação dos hooks.
                Se você quiser saber mais, aqui na Alura, temos a Formação React JS, onde mergulhamos ainda mais no conceito de hooks e falamos de todo ecossistema do React.
                Te vejo numa próxima, até mais!`
            }
        ]
    },
    {
        title: "React Router Dom",
        content: [
            {
                text: `Em um site acessamos várias páginas, como por exemplo, página inicial, contatos, sobre e perfil. Para navegar entre as páginas de uma aplicação React.JS precisaremos criar rotas, onde cada rota vai representar uma tela.
                Para trabalhar com rotas no React vamos utilizar um pacote chamado React Router Dom que precisa ser instalado no nosso projeto. É ele que nos auxiliará na criação da navegação.`
            },
            {
                subtitle: "Instalação e Configuração",
                text: `Antes de aplicar o conceito de navegação e instalar o pacote React Router Dom precisamos criar um projeto React. Para isso execute o Código 1.`
            },
            {
                example: `npx create-react-app react-rotas`
            },
            {
                text: `Após a criação do novo projeto em React, precisamos instalar o pacote React Router Dom que vai manipular as rotas do nosso projeto React. Antes disso acesse a pasta do projeto executando o comando do Código 2.`
            },
            {
                example: `cd react-rotas`
            },
            {
                text: `A instalação de pacotes nos nossos projetos é feita através de um gerenciador de pacotes, que pode ser o NPM ou o Yarn. Nesse artigo manteremos o foco no NPM por ser comumente usado, para instalar o pacote react router dom. Basta executar o comando do Código 3 no terminal.`
            },
            {
                example: `npm install react-router-dom`
            },
            {
                text: `Com projeto criado e o pacote instalado, abriremos nossa aplicação em um editor de texto ou IDE de sua preferência e implementar a navegação do nosso projeto.`
            },
            {
                subtitle: "Criando o arquivo de rotas",
                text: `Neste ponto vamos criar o arquivo de rotas da nossa aplicação, o routes.js. Seu código pode ser visto no Código 4.`,
                img: reactRouterDomImg1
            },
            {
                text: `Note que na linha 2 do arquivo routes.js importamos dois componentes do pacote do react-router-dom: BrowserRouter e Route.
                Esses dois componentes provêm e gerenciam as rotas dentro da nossa aplicação. Vamos aprender a função de cada um.
                BrowserRouter: é um componente responsável por informar a nossa aplicação que teremos um roteamento de componentes, por conta disso ele ficará em volta dos componentes <Route>.
                Route: componente que associa a rota ao componente. Nele temos três parâmetros: component, path e exact. O parâmetro component recebe o componente que precisa ser exibido ao acessar a rota. O parâmetro path é o caminho na URL que precisa ser acessado para mostrar o componente, definido pelo parâmetro component. O parâmetro exact determina qual o componente vai ser exibido apenas se a rota for igual ao definido entre aspas, no nosso caso se for exatamente "/".
                Os componentes Home, Sobre e Usuario que foram importados em routes.js serão criados mais a frente ainda neste artigo, então não se preocupe com eles nesse momento.
                Em nosso arquivo App.js precisaremos importar o routes.js, para usarmos a navegação através das páginas em nossa aplicação, conforme mostra o Código 5.`,
                img: reactRouterDomImg2
            },
            {
                text: `O próximo passo é criar nossos componentes que serão exibidos de acordo com a URL acessada pelos nossos usuários. O primeiro será o componente Home.
                Para cada componente, deixaremos uma mensagem e um Link para retornar a página inicial.`
            },
            {
                subtitle: "Componente Home",
                text: `O código do componente Home (arquivo Home.js) pode ser visto no Código 6.`,
                img: reactRouterDomImg3
            },
            {
                text: `O componente Home foi estruturado para ser a nossa página inicial, nele temos dois links que nos permite navegar para as páginas Sobre e Usuario.
                Observando o código vemos que existe um componente chamado <Link> que foi usado duas vezes como pode ser visto nas linhas 11 e 14.
                Esse componente, que pertence ao pacote react-router-dom vai substituir a nossa tag <a> do HTML para acessar as páginas do próprio projeto. Além disso, recebe o parâmetro to. Ele representa o nome da rota que será acessada pela URL.
                O componente Link possui duas tags: uma de abertura e uma de fechamento. Entre as duas tags (abertura e fechamento) será inserido o conteúdo que ficará disponível para ser clicado. Veja um exemplo no Código 7.`
            },
            {
                example: `<Link to="/">retornar a página inicial</Link>`
            },
            {
                text: `No nosso exemplo inserimos o texto "retornar a página inicial", que ao ser clicado exibirá o componente referente a rota /.
                A tag <a> será utilizada na programação React para acessar links externos ou links âncora da própria página.`
            },
            {
                subtitle: "Componentes Sobre e Usuário",
                text: `As páginas de Sobre e Usuário tem a mesma estrutura: têm o título da página e um link para retornar a página inicial.
                Veja o código do componente Sobre (arquivo Sobre.js) no Código 8.`,
                img: reactRouterDomImg4
            },
            {
                text: `Veja o código do componente Usuario (arquivo Usuario.js) no Código 9.`,
                img: reactRouterDomImg5
            },
            {
                subtitle: "Executando a aplicação",
                text: `Agora que já configuramos nosso arquivo de rotas e nossos componentes, acesse o projeto e execute o comando do Código 10.`,
            },
            {
                example: `npm start`
            }
        ]
    },
    {
        title: "Javascript",
        content: [
            {
                text: `JavaScript é uma linguagem de programação que permite a você implementar itens complexos em páginas web — toda vez que uma página da web faz mais do que simplesmente mostrar a você informação estática — mostrando conteúdo que se atualiza em um intervalo de tempo, mapas interativos ou gráficos 2D/3D animados, etc. — você pode apostar que o JavaScript provavelmente está envolvido. É a terceira camada do bolo das tecnologias padrões da web, duas das quais (HTML e CSS) nós falamos com muito mais detalhes em outras partes da Área de Aprendizado.`,
                img: javascriptImg1
            },
            {
                text: `HTML é a linguagem de marcação que nós usamos para estruturar e dar significado para o nosso conteúdo web. Por exemplo, definindo parágrafos, cabeçalhos, tabelas de conteúdo, ou inserindo imagens e vídeos na página.
                CSS é uma linguagem de regras de estilo que nós usamos para aplicar estilo ao nosso conteúdo HTML. Por exemplo, definindo cores de fundo e fontes, e posicionando nosso conteúdo em múltiplas colunas.
                JavaScript é uma linguagem de programação que permite a você criar conteúdo que se atualiza dinamicamente, controlar múltimídias, imagens animadas, e tudo o mais que há de intessante. Ok, não tudo, mas é maravilhoso o que você pode efetuar com algumas linhas de código JavaScript.`
            },
            {
                subtitle: "Então o que ele pode realmente fazer?",
                text: `O núcleo da linguagem JavaScript consiste em alguns benefícios comuns da programação que permite a você fazer coisas como:
                Armazenar conteúdo útil em variáveis. No exemplo acima, a propósito, nós pedimos que um novo nome seja inserido e armazenamos o nome em uma variável chamada nome.
                Operações com pedaços de texto (conhecidos como "strings" em programação). No exemplo acima, nós pegamos a string "Jogador 1: " e concatenamos (juntamos) com a variável nome para criar o texto completo "Jogador 1: Chris".
                Executar o código em resposta a determinados eventos que ocorrem em uma página da Web. Nós usamos o click (en-US) no nosso exemplo acima para que quando clicassem no botão, rodasse o código que atualiza o texto.
                E muito mais!
                O que é ainda mais empolgante é a funcionalidade construída no topo do núcleo da linguagem JavaScript. As APIs (Application Programming Interfaces - Interface de Programação de Aplicativos) proveem a você superpoderes extras para usar no seu código JavaScript.
                APIs são conjuntos prontos de blocos de construção de código que permitem que um desenvolvedor implemente programas que seriam difíceis ou impossíveis de implementar. Eles fazem o mesmo para a programação que os kits de móveis prontos para a construção de casas - é muito mais fácil pegar os painéis prontos e parafusá-los para formar uma estante de livros do que para elaborar o design, sair e encontrar a madeira, cortar todos os painéis no tamanho e formato certos, encontrar os parafusos de tamanho correto e depois montá-los para formar uma estante de livros.
                Elas geralmente se dividem em duas categorias.`,
                img: javascriptImg2
            },
            {
                text: `APIs de navegadores já vem implementadas no navegador, e são capazes de expor dados do ambiente do computador, ou fazer coisas complexas e úteis. Por exemplo:
                A API DOM (Document Object Model) permite a você manipular HTML e CSS, criando, removendo e mudando HTML, aplicando dinamicamente novos estilos para a sua página, etc. Toda vez que você vê uma janela pop-up aparecer em uma página, ou vê algum novo conteúdo sendo exibido (como nós vimos acima na nossa simples demonstração), isso é o DOM em ação.
                A API de Geolocalização recupera informações geográficas. É assim que o Google Maps consegue encontrar sua localização e colocar em um mapa.
                As APIs Canvas e WebGL permite a você criar gráficos 2D e 3D animados. Há pessoas fazendo algumas coisas fantásticas usando essas tecnologias web — veja Chrome Experiments e webglsamples.
                APIs de áudio e vídeo como HTMLMediaElement (en-US) e WebRTC permitem a você fazer coisas realmente interessantes com multimídia, tanto tocar música e vídeo em uma página da web, como capturar vídeos com a sua câmera e exibir no computador de outra pessoa (veja Snapshot demo para ter uma ideia).
                Nota: Muitas demonstrações acima não vão funcionar em navegadores antigos — quando você for experimentar, é uma boa ideia usar browsers modernos como Firefox, Edge ou Opera para ver o código funcionar. Você vai precisar estudar testes cross browser com mais detalhes quando você estiver chegando perto de produzir código (código real que as pessoas vão usar).
                APIs de terceiros não estão implementados no navegador automaticamente, e você geralmente tem que pegar seu código e informações em algum lugar da Web. Por exemplo:
                A API do Twitter permite a você fazer coisas como exibir seus últimos tweets no seu website.
                A API do Google Maps permite a você inserir mapas customizados no seu site e outras diversas funcionalidades.
                Note: Essas APIs são avançadas e nós não vamos falar sobre nenhuma delas nesse módulo.Vo cê pode achar muito mais sobre elas em nosso módulo APIs web no lado cliente. 
                Tem muito mais coisas disponíveis! Contudo, não fique animado ainda. Você não estará pronto para desenvolver o próximo Facebook, Google Maps ou Instagram depois de estudar JavaScript por 24 horas — há um monte de coisas básicas para estudar primeiro. E é por isso que você está aqui — vamos começar!`
            },
            {
                subtitle: "O que JavaScript está fazendo na sua página web?",
                text: `Aqui nós vamos realmente começar a ver algum código, e enquanto fazemos isso vamos explorar o que realmente acontece quando você roda algum código JavaScript na sua página.
                Vamos recaptular brevemente a história do que acontece quando você carrega uma página web em um navegador (falamos sobre isso no nosso artigo Como o CSS funciona). Quando você carrega uma página web no seu navegador, você está executando seu código (o HTML, CSS e JavaScript) dentro de um ambiente de execução (a guia do navegador). Isso é como uma fábrica que pega a matéria prima (o código) e transforma em um produto (a página web).`,
                img: javascriptImg3
            },
            {
                text: `Um uso muito comum do JavaScript é modificar dinamicamente HTML e CSS para atualizar uma interface do usuário, por meio da API do Document Object Model (conforme mencionado acima). Observe que o código em seus documentos web geralmente é carregado e executado na ordem em que aparece na página. Se o JavaScript carregar e tentar executar antes do carregamento do HTML e CSS afetado, poderão ocorrer erros. Você aprenderá maneiras de contornar isso mais adiante neste artigo, na seção Estratégias de carregamento de scripts .`
            },
            {
                subtitle: "Segurança do navegador",
                text: `Segurança do navegador
                Cada guia do navegador tem seu próprio espaço para executar código (esses espaços são chamados de "ambientes de execução", em termos técnicos) — isso significa que na maioria dos casos o código em cada guia está sendo executado separadamente, e o código em uma guia não pode afetar diretamente o código de outra guia — ou de outro website. Isso é uma boa medida de segurança — se esse não fosse o caso, então hackers poderiam começar a escrever código para roubar informações de outros websites, e fazer outras coisas más.`
            },
            {
                subtitle: "Código interpretado x compilado",
                text: `Você pode ouvir os termos interpretado e compilado no contexto da programação. JavaScript é uma linguagem interpretada — o código é executado de cima para baixo e o resultado da execução do código é imediatamente retornado. Você não tem que transformar o código em algo diferente antes do navegador executa-lo.
                Linguagens compiladas, por outro lado, são transformadas (compiladas) em algo diferente antes que sejam executadas pelo computador. Por exemplo, C/C++ são compiladas em linguagem Assembly, e depois são executadas pelo computador.
                JavaScript é uma linguagem de programação leve e interpretada. O navegador recebe o código JavaScript em sua forma de texto original e executa o script a partir dele. Do ponto de vista técnico, a maioria dos intérpretes modernos de JavaScript realmente usa uma técnica chamada compilação just-in-time para melhorar o desempenho; o código-fonte JavaScript é compilado em um formato binário mais rápido enquanto o script está sendo usado, para que possa ser executado o mais rápido possível. No entanto, o JavaScript ainda é considerado uma linguagem interpretada, pois a compilação é manipulada em tempo de execução, e não antes.
                Há vantagens em ambos os tipos de linguagem, mas nós não iremos discutir no momento.`
            },
            {
                subtitle: "Lado do servidor x Lado do cliente",
                text: `Você pode também ouvir os termos lado do servidor (server-side) e lado do cliente (client-side), especialmente no contexto de desenvolvimento web. Códigos do lado do cliente são executados no computador do usuário — quando uma página web é visualizada, o código do lado do cliente é baixado, executado e exibido pelo navegador. Nesse módulo JavaScript nós estamos explicitamente falando sobre JavaScript do lado do cliente.
                Códigos do lado do servidor, por outro lado, são executados no servidor e o resultado da execução é baixado e exibido no navegador. Exemplos de linguagens do lado do servidor populares incluem PHP, Python, Ruby, e ASP.NET. E JavaScript! JavaScript também pode ser usada como uma linguagem server-side, por exemplo, no popular ambiente Node.js — você pode encontrar mais sobre JavaScript do lado do servidor no nosso tópico Websites dinâmicos - Programação do lado do servidor.`
            },
            {
                subtitle: "Código dinâmico x estático",
                text: `A palavra dinâmico é usada para descrever tanto o JavaScript client-side como o server-side — essa palavra se refere a habilidade de atualizar a exibição de uma página web/app para mostrar coisas diferentes em circunstâncias diferentes, gerando novo conteúdo como solicitado. Código do lado do servidor dinamicamente gera novo conteúdo no servidor, puxando dados de um banco de dados, enquanto que JavaScript do lado do cliente dinamicamente gera novo conteúdo dentro do navegador do cliente, como criar uma nova tabela HTML com dados recebidos do servidor e mostrar a tabela em uma página web exibida para o usuário. Os significados são ligeiramente diferente nos dois contextos, porém relacionados, e ambos (JavaScript server-side e client-side) geralmente trabalham juntos.
                Uma página web sem atualizações dinâmicas é chamada de estática — ela só mostra o mesmo conteúdo o tempo todo.`
            },
            {
                subtitle: "Como você adiciona JavaScript na sua página?",
                text: `O JavaScript é inserido na sua página de uma maneira similar ao CSS. Enquanto o CSS usa o elemento <link> para aplicar folhas de estilo externas e o elemento <style> para aplicar folhas de estilo internas, o JavaScript só precisa de um amigo no mundo do HTML — o elemento <script>.`
            },
            {
                subtitle: "Estratégias para o carregamento de scripts",
                text: `Há um considerável número de problemas envolvendo o carregamento de scripts na ordem correta. Infelizmente, nada é tão simples quanto parece ser! Um problema comum é que todo o HTML de uma página é carregado na ordem em que ele aparece. Se você estiver usando Javascript para manipular alguns elementos da página (sendo mais preciso, manipular o Document Object Model), seu código não irá funcionar caso o JavaScript for carregado e executado antes mesmo dos elementos HTML estarem disponíveis.
                Nos exemplos acima, tanto nos scripts internos ou externos, o JavaScript é carregado e acionado dentro do cabeçalho do documento, antes do corpo da página ser completamente carregado. Isso poderá causar algum erro. Assim, temos algumas soluções para isso.
                No exemplo interno, você pode ver essa estrutura em volta do código:`
            },
            {
                example: `document.addEventListener("DOMContentLoaded", function() {
                    ...
                  });`
            },
            {
                text: `Isso é um event listener (ouvidor de eventos), que ouve e aguarda o disparo do evento "DOMContentLoaded" vindo do browser, evento este que significa que o corpo do HTML está completamente carregado e pronto. O código JavaScript que estiver dentro desse bloco não será executado até que o evento seja disparado, portanto, o erro será evitado (você irá aprender sobre eventos mais tarde).
                No exemplo externo, nós usamos um recurso moderno do JavaScript para resolver esse problema: Trata-se do atributo defer, que informa ao browser para continuar renderizando o conteúdo HTML uma vez que a tag <script> foi atingida.`
            },
            {
                example: `<script src="script.js" defer></script>`
            },
            {
                text: `Neste caso, ambos script e HTML irão carregar de forma simultânea e o código irá funcionar.
                Nota: No caso externo, nós não precisamos utilizar o evento DOMContentLoaded porque o atributo defer resolve o nosso problema. Nós não utilizamos defer como solução para os exemplos internos pois defer funciona apenas com scripts externos.
                Uma solução à moda antiga para esse problema era colocar o elemento script bem no final do body da página (antes da tag </body>). Com isso, os scripts iriam carregar logo após todo o conteúdo HTML. O problema com esse tipo de solução é que o carregamento/renderização do script seria completamente bloqueado até que todo o conteúdo HTML fosse analisado. Em sites de maior escala, com muitos scripts, essa solução causaria um grande problema de performance e deixaria o site lento. `
            },
            {
                subtitle: "async e defer",
                text: `Atualmente, há dois recursos bem modernos que podermos usar para evitar o problema com o bloqueio de scripts — async e defer (que vimos acima). Vamos ver as diferenças entre esses dois?
                Os scripts que são carregados usando o atributo async (veja abaixo) irão baixar o script sem bloquear a renderização da página e irão executar imediatamente após o script terminar de ser disponibilizado. Nesse modo você não tem garantia nenhuma que os scripts carregados irão rodar em uma ordem específica, mas saberá que dessa forma eles não irão impedir o carregamento do restante da página. O melhor uso para o async é quando os scripts de uma página rodam de forma independente entre si e também não dependem de nenhum outro script.
                Por exemplo, se você tiver os seguintes elementos script:`,
                img: javascriptImg4
            },
            {
                text: `Você não pode garantir que o script. jquery.js carregará antes ou depois do script2.js e script3.js . Nesse caso, se alguma função desses scripts dependerem de algo vindo do jquery, ela produzirá um erro pois o jquery ainda não foi definido/carregado quando os scripts executaram essa função.
                async deve ser usado quando houver muitos scripts rodando no background, e você precisa que estejam disponíveis o mais rápido possível. Por exemplo, talvez você tenha muitos arquivos de dados de um jogo para carregar que serão necessários assim que o jogo iniciar, mas por enquanto, você só quer entrar e ver a tela de carregamento, a do titulo do jogo e o lobby, sem ser bloqueado pelo carregamento desses scripts.
                Scripts que são carregados utilizando o atributo defer (veja abaixo) irão rodar exatamente na ordem em que aparecem na página e serão executados assim que o script e o conteúdo for baixado.`,
                img: javascriptImg5
            },
            {
                text: `Todos os scripts com o atributo defer irão carregar na ordem que aparecem na página. No segundo exemplo, podemos ter a certeza que o script jquery.js irá carregar antes do script2.js e script3.js e o script2.js irá carregar antes do script3.js. Os scripts não irão rodar sem que antes todo o conteúdo da página seja carregado, que no caso, é muito útil se os seus scripts dependem de um DOM completamente disponibilizado em tela (por exemplo, scripts que modificam um elemento).
                Resumindo:
                async e defer istruem o browser a baixar os scripts numa thread (processo) á parte, enquanto o resto da página (o DOM, etc.) está sendo baixado e disponibilizado de forma não bloqueante.
                Se os seus scripts precisam rodar imediatamente, sem que dependam de outros para serem executados, use async.
                Se seus scripts dependem de outros scripts ou do DOM completamente disponível em tela, carregue-os usando defer e coloque os elementos <script> na ordem exata que deseja que sejam carregados.`
            }
        ]
    },
    {
        title: "Array includes()",
        content: [
            {
                subtitle: "Sumário",
                text: `O método includes() determina se um array contém um determinado elemento, retornando true ou false apropriadamente.`
            },
            {
                subtitle: "Sintaxe",
                example: `array.includes(searchElement[, fromIndex])`
            },
            {
                subtitle: "Parâmetros"
            },
            {
                subtitle2: "searchElement",
                text: `O elemento a buscar`
            },
            {
                subtitle2: "fromIndex",
                text: `Opcional. A posição no array de onde a busca pelo searchElement se iniciará. Por padrão, 0.`
            },
            {
                subtitle: "Exemplos",
                img: arrayIncludesImg1
            }
        ]
    },
    {
        title: "String includes()",
        content: [
            {
                text: `O método includes() determina se um conjunto de caracteres pode ser encontrado dentro de outra string, retornando true ou false.`
            },
            {
                subtitle: "Sintaxe",
                example: `str.includes(searchString[, position])`
            },
            {
                subtitle: "Parâmetros"
            },
            {
                subtitle2: "searchString",
                text: `É o conjunto de caracteres que será pesquisado dentro desta string.`
            },
            {
                subtitle2: "position",
                text: `Opcional. É um número inteiro que indica por onde a busca iniciará, referente ao índice da string a ser pesquisada. O valor padrão é 0.`
            },
            {
                subtitle: "Valor retornado",
                text: `true se o conjunto de caracteres for encontrado em algum lugar dentro da string sendo pesquisada. Do contrário, retorna false.`
            },
            {
                subtitle: "Descrição",
                text: `Este método permite conferir se uma string contém um determinado conjunto de caracteres.`
            },
            {
                subtitle: "Case-sensitivity",
                text: `O método includes() é case sensitive. Por exemplo, a seguinte expressão retorna false:`
            },
            {
                example: `'Bandeira do Brasil'.includes('brasil'); // retorna false`
            },
            {
                subtitle: "Exemplos",
                img: stringIncludesImg1
            }
        ]
    }
];

export default content;